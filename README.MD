# 用java简单实现memcache服务端
   ##设计思想
    
        1.IO模型：网络协议暂时只处理了TCP，整个模型类似于事件分发机制，主线程负责初始化分发线程与后台线程，然后循环接收socket，创建连接类。
        分发线程通过读取连接类，根据连接状态分发给不同的线程。针对连接不同的状态，创建了不同的Runnable类进行处理
        2.存储模型：利用linkedHashMap和读写锁实现缓存的存储结构并保证线程安全。
        3.过期策略：通过后台线程对lrucache进行遍历，或者是get访问触发惰性删除，所以删除分为定期删除和惰性删除
        4.整体的日志都是存在外部的，地址为当前目录/~/logs，里面有error.log和info.log。不过cache操作的get和set我还是输出到控制台了，毕竟便于测试嘛
        
   ##实现思路
    
        1.主线程创建Connection阻塞队列，因为可能需要自己的事件线程放回其队列，所以可能会产生线程冲突，需要使用阻塞队列
        2.设计Connection类，因为这个Connection类是贯穿从读取到执行到回写的整个流程的，所以他要包含读取字节的builder，回写的message，socket套接字，连接状态，所在的链表。
        3.waiting线程主要检测有没有数据，如果没有，就sleep在检测，当持续一定次数还是没有数据设置连接状态为close，有数据就转化为read，执行read线程可能发生tcp粘包，对这个情况就是读取一定字节然后执行解析，解析没有读到\n结束符就再去读。读到了就再次开始解析，set操作不一样，如果解析了是set，而且没读到下一个数据块就再去读，读到了就开始解析。解析完进行回写，回写完又开始解析，中间如果出现错误就进入关闭状态了
        4.当然，整个流程不是单线程的，而是通过改变connection状态然后由时间分发进行的。有点类似状态机
        5.后台线程主要检测一个key的失效时间有没有在当前时间之前，如果在，进行删除，每隔一段时间检测一次
        6.存储采用LinkedHashMap，V值为value+expireTime（失效时间）+flags+deleted(记录删除标志，因为delete可以带times，所以需要对之后需要delete的实现deleted标志来影响之后get，add等命令)
        7.cache的get和set整个操作都是按照协议进行的实现，所以大致都是业务get，set，add，delete基本都是业务逻辑
        
   ##不足与构思
        
        1.因为时间紧凑，存储结构没有做到内存管理，缓存实现这样当然够了，但是容易产生内存碎片，还有就是没有对缓存系统的一些属性进行记录，比如访问次数什么的。
        2.没有做到分布式，这个以后再看吧，因为memcache的分布式也是客户端去实现的
        3.网络模型和更多的命令吧，还有整体的性能，
        4.对客户端的信息记录只记录了很少的一些东西，没有对客户端信息进行更多记录，只是使用Connection类将核心的东西进行了记录
        5.不管结果怎么样，这次作业还是学到了一些东西，因为写这个我参考了memcache的一些处理方法，比如libevent事件模型等等。